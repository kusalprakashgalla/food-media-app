{"ast":null,"code":"'use strict';\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar api = require('./api');\nvar config = require('../config');\nvar _require = require('../utils'),\n  isEmpty = _require.isEmpty,\n  isNumber = _require.isNumber,\n  compute_hash = _require.compute_hash,\n  build_distribution_domain = _require.build_distribution_domain,\n  clear_blank = _require.clear_blank,\n  sort_object_by_key = _require.sort_object_by_key;\nvar _require2 = require('../utils/encoding/base64Encode'),\n  base64Encode = _require2.base64Encode;\nvar Search = function () {\n  function Search() {\n    _classCallCheck(this, Search);\n    this.query_hash = {\n      sort_by: [],\n      aggregate: [],\n      with_field: []\n    };\n    this._ttl = 300;\n  }\n  _createClass(Search, [{\n    key: 'expression',\n    value: function expression(value) {\n      this.query_hash.expression = value;\n      return this;\n    }\n  }, {\n    key: 'max_results',\n    value: function max_results(value) {\n      this.query_hash.max_results = value;\n      return this;\n    }\n  }, {\n    key: 'next_cursor',\n    value: function next_cursor(value) {\n      this.query_hash.next_cursor = value;\n      return this;\n    }\n  }, {\n    key: 'aggregate',\n    value: function aggregate(value) {\n      var found = this.query_hash.aggregate.find(function (v) {\n        return v === value;\n      });\n      if (!found) {\n        this.query_hash.aggregate.push(value);\n      }\n      return this;\n    }\n  }, {\n    key: 'with_field',\n    value: function with_field(value) {\n      var found = this.query_hash.with_field.find(function (v) {\n        return v === value;\n      });\n      if (!found) {\n        this.query_hash.with_field.push(value);\n      }\n      return this;\n    }\n  }, {\n    key: 'sort_by',\n    value: function sort_by(field_name) {\n      var dir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"desc\";\n      var sort_bucket = void 0;\n      sort_bucket = {};\n      sort_bucket[field_name] = dir;\n\n      // Check if this field name is already stored in the hash\n      var previously_sorted_obj = this.query_hash.sort_by.find(function (sort_by) {\n        return sort_by[field_name];\n      });\n\n      // Since objects are references in Javascript, we can update the reference we found\n      // For example,\n      if (previously_sorted_obj) {\n        previously_sorted_obj[field_name] = dir;\n      } else {\n        this.query_hash.sort_by.push(sort_bucket);\n      }\n      return this;\n    }\n  }, {\n    key: 'ttl',\n    value: function ttl(newTtl) {\n      if (isNumber(newTtl)) {\n        this._ttl = newTtl;\n        return this;\n      }\n      throw new Error('New TTL value has to be a Number.');\n    }\n  }, {\n    key: 'to_query',\n    value: function to_query() {\n      var _this = this;\n      Object.keys(this.query_hash).forEach(function (k) {\n        var v = _this.query_hash[k];\n        if (!isNumber(v) && isEmpty(v)) {\n          delete _this.query_hash[k];\n        }\n      });\n      return this.query_hash;\n    }\n  }, {\n    key: 'execute',\n    value: function execute(options, callback) {\n      if (callback === null) {\n        callback = options;\n      }\n      options = options || {};\n      return api.search(this.to_query(), options, callback);\n    }\n  }, {\n    key: 'to_url',\n    value: function to_url(ttl, next_cursor) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var apiSecret = 'api_secret' in options ? options.api_secret : config().api_secret;\n      if (!apiSecret) {\n        throw new Error('Must supply api_secret');\n      }\n      var urlTtl = ttl || this._ttl;\n      var query = this.to_query();\n      var urlCursor = next_cursor;\n      if (query.next_cursor && !next_cursor) {\n        urlCursor = query.next_cursor;\n      }\n      delete query.next_cursor;\n      var dataOrderedByKey = sort_object_by_key(clear_blank(query));\n      var encodedQuery = base64Encode(JSON.stringify(dataOrderedByKey));\n      var urlPrefix = build_distribution_domain(options.source, options);\n      var signature = compute_hash(\"\".concat(urlTtl).concat(encodedQuery).concat(apiSecret), 'sha256', 'hex');\n      var urlWithoutCursor = \"\".concat(urlPrefix, \"/search/\").concat(signature, \"/\").concat(urlTtl, \"/\").concat(encodedQuery);\n      return urlCursor ? \"\".concat(urlWithoutCursor, \"/\").concat(urlCursor) : urlWithoutCursor;\n    }\n  }], [{\n    key: 'instance',\n    value: function instance() {\n      return new Search();\n    }\n  }, {\n    key: 'expression',\n    value: function expression(value) {\n      return this.instance().expression(value);\n    }\n  }, {\n    key: 'max_results',\n    value: function max_results(value) {\n      return this.instance().max_results(value);\n    }\n  }, {\n    key: 'next_cursor',\n    value: function next_cursor(value) {\n      return this.instance().next_cursor(value);\n    }\n  }, {\n    key: 'aggregate',\n    value: function aggregate(value) {\n      return this.instance().aggregate(value);\n    }\n  }, {\n    key: 'with_field',\n    value: function with_field(value) {\n      return this.instance().with_field(value);\n    }\n  }, {\n    key: 'sort_by',\n    value: function sort_by(field_name) {\n      var dir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'asc';\n      return this.instance().sort_by(field_name, dir);\n    }\n  }, {\n    key: 'ttl',\n    value: function ttl(newTtl) {\n      return this.instance().ttl(newTtl);\n    }\n  }]);\n  return Search;\n}();\nmodule.exports = Search;","map":null,"metadata":{},"sourceType":"script"}